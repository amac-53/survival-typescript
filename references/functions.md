# 関数

## 関数宣言
- `function increment(num: number): number{}`の形式で，引数の型注釈を省略すると`any`になり，戻り値の型が省略された場合は推論される（return が複数あり，異なる型を返している場合はユニオン型になる）
- `noImplicitAny`を`true`にすることで引数の型アノテーションを必須にできる（`tsconfig`参照）

## 関数式
- 関数宣言の関数名を変数に代入できるもので，基本関数名を省略して書く（**式とは評価した結果が値になるもの**）
- もし関数名を省略しない場合は，関数の再帰呼び出しとして使用できる名前になる
- 呼び出しは`変数名()`でok
- オブジェクトのプロパティに直接代入可能
- 関数型の変数に代入する場合は型注釈を省略しても推論が効く

## アロー関数
- アロー関数は式
- オブジェクトを return するときは`(n) => ({foo: n + 1})`　のように外側の括弧を忘れないように
- **引数が１つ，戻り値の式が１つのときだけ括弧を省略可能だが，この場合，型注釈を書けない**
- `noImplicitAny`を`true`にすることで上記のアロー関数の省略をエラーにすることも可能（`map`関数などの引数の型が推論できる場合はエラーに引っかからない）

## 関数の型の宣言
- 型エイリアスを用いて型を先に定義してしまうことも多い（**型宣言**という）
- 2通りの宣言の方法がある（`type Increment = (num: number) => number;`（アロー関数構文） or `type Increment = {(num: number): number;};`（メソッド構文））
- 型宣言をすることで，アロー関数や関数式の変数の方に型を書くことができ，右辺側の型を省略することが可能
- 順序を逆にして，先に関数で引数，戻り値の型を宣言しておいて，その関数に対して`typeof`を用いることで型宣言することも可能（`type Increment = typeof increment;`）

## 関数宣言と巻き上げ
- **関数宣言では巻き上げが起こる**ので，定義前に呼び出すことが可能になっている一方で，**関数式では巻き上げが起こらない**ので`ReferenceError`が起こる

## 従来の関数とアロー関数の違い
- `function`キーワードをいちいち書かなくていいので記述が楽
- 余計な機能として入っていたコンストラクタを削除した
- 従来の関数に入っていた`this`は環境依存で，ブラウザでは window オブジェクトだが，strict モードを使うと`undefined`になり，オブジェクトのメソッドとして呼び出すとオブジェクト自体を指すようになる．またコンストラクタとして呼び出すと生成中のオブジェクトを指すようになる
- アロー関数の this はレキシカルスコープで静的なので，定義したときに this が決定し，呼び出し方に左右されない
- `alwaysStrict`を`true`にすることでコンパイル後の JS が strict モードになる
- JS のモジュールモードを使うことで import, export が使用できるようになるが，このとき自動的に strict モードになる
- JS の関数はオブジェクトであり，`call`, `apply`, `bind`の３つのメソッドが生えている
- 従来の関数ではこれらの関数の第一引数に`this`がさすものを決定できていたが，アロー関数では上書き不可能
- 従来は`arguments`という引数の配列を表す変数が自動的に定義されていたが，ほとんどの関数では使わないので，もし使いたい場合にはレストパラメータを使う
- 従来の関数では`function*`と`yield`文で値を生成できるジェネレータを定義していたが，アロー関数では使用できない
- 従来の関数では，引数の重複が許されており，最後に宣言された値が採用される方式だったが，バグを引き起こしやすいのでアロー関数から排除された
- 従来の関数は var で宣言しているのと同じで重複した関数名があった場合に上書きしてしまうので危険だが，アロー関数は`const`, `let`の変数として書けるのでそんなことは起こりえない
- 関数宣言では巻き上げが起こり，var の巻き上げと異なり，実装まで巻き上げられる
- 基本はアロー関数を使うのがいいが，関数と一目でわかりやすいコードにする or `addEventListner`, オブジェクトのメソッドとして使用するには従来の関数が便利な場合もある

## 関数は値
- JSでは関数は値なので，再宣言，代入が可能
- 再代入などによるバグを防ぎたい場合は const を使うのがいいが，TS ではそもそも重複した関数宣言を警告してくれる
- 関数はローカルスコープ

## 関数はオブジェクト
- JS の関数はオブジェクトなのでプロパティを持たせることが可能

## 戻り値がない関数とvoid型 (void type)
- 戻り値がない関数は`void`で注釈する（戻り値のない関数を呼び出したときに返る値は`undefined`）
- `undefined`で注釈すると，戻り値が必要になってしまうので注意
- もし戻り値が返ったり返らなかったりするなら`undefined`を含むユニオン型を使うのが一般的
- **`void`は`undefined`の上位型で，undefined -> void の代入はできても逆は不可能**
- この特徴により`void`で定義された関数を変数に間違えて代入した場合コンパイラが警告してくれるのでバグを防ぎやすくなる（`void`の存在意義）

## 関数の引数 (function parameter)
- **JS では引数の個数チェックが行われない（少ない場合は`undefined`, 多い場合は無視するという方針）**
- このため，厳密にチェックしたい場合は`length`でチェックする必要がある
- TS では勝手にチェックしてくれるので`length`のロジックは必要ない
- JS では引数の型もチェックしないので，例えば関数内に`str.length`というロジックがあり，`str`を引数にしている場合，それが何であっても基本は実行されるため，`if(typeof str !== "string")`というプリミティブ型のチェックをはさむ必要がある
- 一方で，TS は型注釈を書けるので解決

## 値渡し(pass-by-value)と参照渡し(pass-by-reference)
- **JS はオブジェクトは参照渡しで，プリミティブは値渡しの仕様**
- オブジェクトは異なる変数でも同じ値を共有する仕組みだが，**その変数に全く異なるオブジェクトを再代入した場合は元の変数に影響を与えなくなる（特殊）**

## オプション引数 (optional parameter)
- 引数を省略可能にする TS 特有の機能があり，`person?: string`みたいな形で書ける（`string | undefined`という型で扱われる）
- 省略された場合は`undefined`になるので，string のメソッドを使いたい場合は２つのいずれかの方法を実行することになる
  1. デフォルト値を代入（Null 合体演算子，型ガードによる代入方法 or **デフォルト引数**）
  2. 型ガードにより，処理を分ける（内部に return を書く）
- **そのままの`string | undefined`で引数を書くと引数の省略を行えなくなるので，もし省略したいならこれを使う必要がある**
- オプション引数の後に普通の引数を置けないので注意（python と同じ）

## デフォルト引数 (default parameter)
- JS では引数を省略すると undefined になり，その時はデフォルト引数が採用される（`num: number = 1`）
- `undefined`を渡したときもデフォルト引数が採用されるが，`null`だと適用されない点に注意
- **デフォルト引数には式を書くことができる**が，非同期処理は書けない
- 型推論が効く

## 残余引数/可変長引数 (rest parameter)
- 引数の数が決まっていない場合に使用でき，最後に置く必要がある
- **型注釈は配列で書く**（`...params: number[]`）
- JS の組み込み関数として`Math.max()`があるが，値を渡すときはばらして渡す必要があるので，スプレッド構文で渡す必要がある

## this引数 (this parameter)
- TS では，従来の関数（アロー関数以外）とクラスのメソッドの第一引数は this を受け取ることができる
- これを指定しないと，どのコンテキストで実行するかが定かでないので実行時に例外が走る

## 分割代入引数 (destructuring assignment parameter)
- オブジェクトや配列の一部を利用したい場合などに便利
- オブジェクトのプロパティを別名で受け取る場合は`プロパティ名: 別名`とする
- 配列を受け取る場合は，角括弧
- 型注釈はオブジェクトならオブジェクト型，配列なら配列で書く
- `noUncheckedIndexedAccess`を`true`にした場合，分割代入は`undefined`とのユニオン型になる
- 配列の分割代入はタプル型でも書くことができるが，`undefined`とのユニオン型にはならない点に注意
- JS では代入される要素がない場合は，`undefined`が代入されるが，TS ではコンパイルが通らない
- 分割代入引数の個別のプロパティのデフォルト値はそれぞれの変数の後に`=値`でつなげるとよいが，型注釈はその後に`変数名?: 型`の**オプションで書く必要がある**
- 分割代入の**引数全体**の既定値を設定することで，**引数全体がない or `undefined`の場合に採用される**．型注釈を入れる場合は`変数名: 型注釈 = 全体の既定値`となる 
- プロパティごとのデフォルト引数と併用も可能だが，全体の既定値よりもプロパティごとの値が優先される
- JS ではプロパティ名を同じ変数名があるならプロパティ名を省略可能

## キーワード引数とOptions Objectパターン
- python の機能で，呼び出し側で明示的に変数名を指定することで呼び出しの順に依存しない形で引数を書ける**キーワード引数**というやつがある
- JS, TS ではこの機能はないが似たことを実現できる**Options Object パターン**がある
- これはオブジェクト１つを引数に取る設計のものを指す
- 分割代入引数を利用することで引数部分をシンプルに描ける
- 通常の**位置引数**呼び出しだと，引数追加時に直感的でない引数並びになることが多いため変更に弱いが，Options Object パターンはそうでない
- また位置引数では呼び出しの順番によっては引数を省略できず`undefined`を書く必要があるが，Options Object パターンでは省略可能
- 引数名の変更を行う場合，`{元: 後}`にする必要がある
- Options Object をオプショナル引数にしたい場合は，空（`{}`）オブジェクトを指定するとよい
```typescript
function findProducts({
  isSale = false,
  withDetails = false,
  freeShipping = false
}: {
  isSale?: boolean;
  withDetails?: boolean;
  freeShipping?: boolean;
}){
  console.log(isSale, withDetails, freeShipping);
} 

findProducts({ freeShipping: true });
```


## 型ガード関数 (type guard function)
- Type predicate（戻り値が boolean の関数に対して適用できる宣言）を使用する
- 以下の例では，true を返すときは`animal`を`Duck`型と認識するように TS に指示する形になる
```typescript
function isDuck(animal: Animal): animal is Duck {
    return animal instanceof Duck;
}
```

## アサーション関数 (assertion functions)
- Type predicate のほかに型ガード関数として使える方法で，関数が例外を投げるかどうかで判断する（`asserts animal is Duck`と書く）
- この関数が実行されて以降は，`animal`は`Duck`型であると解釈される

## 🚧即時実行関数 (IIFE)

## 🚧コールバック関数 (callback functions)

## オーバーロード関数 (overload function)
- TS の機能で１つの関数に複数の関数シグネチャ（どのような引数をとり，どのような戻り値を返すかといった関数の型のこと）を持つ機能
- シグネチャはインターフェースを書き，最後にすべてのシグネチャを網羅する実装を描く形式
- コンパイルするとシグネチャが消された形になる
- Java などのシグネチャ内に実装する形にしていないのは，オーバーロードが採用されていない JS にコンパイル後に変換されるため，実行時のコードとの乖離をできるだけなくすという方針のためだと考えられる
- シグネチャは上から順にマッチするかを確認する実装なので，狭い条件のものを上に置いて書くという点に注意
- 基本的に引数の有無や型の選択肢が多い程度であれば，オプション引数やユニオン型を使った方がいいまである